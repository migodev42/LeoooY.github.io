<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus v2.0.0-alpha.58">
<title data-react-helmet="true">[译] Blink内核是如何工作的? | DocsShare</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="[译] Blink内核是如何工作的? | DocsShare"><meta data-react-helmet="true" name="description" content="原文链接"><meta data-react-helmet="true" property="og:description" content="原文链接"><meta data-react-helmet="true" property="og:url" content="https://leoooy.github.io//docs/FE/Browser/doc-Blink内核是如何工作的"><link data-react-helmet="true" rel="shortcut icon" href="/img/leo.png"><link data-react-helmet="true" rel="canonical" href="https://leoooy.github.io//docs/FE/Browser/doc-Blink内核是如何工作的"><link rel="stylesheet" href="/styles.5961654d.css">
<link rel="preload" href="/styles.42bc322c.js" as="script">
<link rel="preload" href="/runtime~main.3bd6ec28.js" as="script">
<link rel="preload" href="/main.40fc54e8.js" as="script">
<link rel="preload" href="/common.ee045f54.js" as="script">
<link rel="preload" href="/2.358b1822.js" as="script">
<link rel="preload" href="/3.2cdabb68.js" as="script">
<link rel="preload" href="/1be78505.b7264bde.js" as="script">
<link rel="preload" href="/28.c35099c0.js" as="script">
<link rel="preload" href="/20ac7829.809bff99.js" as="script">
<link rel="preload" href="/17896441.6709d3b9.js" as="script">
<link rel="preload" href="/886b1f25.09ff3141.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=window.matchMedia("(prefers-color-scheme: dark)"),n=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();null!==n?t(n):e.matches&&t("dark")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/leo.png" alt="My Site Logo"><strong class="navbar__title">My DocsShare</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">Notes</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/LeoooY" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://juejin.im/user/5bebc171e51d4511a8090edb/posts" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">掘金</a><a href="https://twitter.com/LeoY233" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Twitter</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_1gtM"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_keGJ moon_1gwN"></span></div><div class="react-toggle-track-x"><span class="toggle_keGJ sun_3CPA"></span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/leo.png" alt="My Site Logo"><strong class="navbar__title">My DocsShare</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs">Notes</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/LeoooY" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://juejin.im/user/5bebc171e51d4511a8090edb/posts" target="_blank" rel="noopener noreferrer" class="menu__link">掘金</a></li><li class="menu__list-item"><a href="https://twitter.com/LeoY233" target="_blank" rel="noopener noreferrer" class="menu__link">Twitter</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_1kjD"><div class="docSidebarContainer_1cYp" role="complementary"><div class="sidebar_1kLs"><div class="menu menu--responsive menu_w2sC"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_2vk4" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Network</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/">TCP3次握手和4次挥手</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">FE</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Browser</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/FE/Browser/doc-Blink内核是如何工作的">[译] Blink内核是如何工作的?</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">React</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/FE/React/doc-ReactHooks使用心得">ReactHooks使用心得</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_FFX1"><div class="container padding-vert--lg docItemWrapper_1cc7"><div class="row"><div class="col docItemCol_2GOA"><div class="docItemContainer_2cwg"><article><header><h1 class="docTitle_1vWb">[译] Blink内核是如何工作的?</h1></header><div class="markdown"><p><a href="https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit?usp=sharing" target="_blank" rel="noopener noreferrer">原文链接</a></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="blink-是如何工作的"></a>Blink 是如何工作的<a aria-hidden="true" tabindex="-1" class="hash-link" href="#blink-是如何工作的" title="Direct link to heading">#</a></h1><p>Author: haraken@
Last update: 2018 Aug 14
Status: PUBLIC
译: <a href="https://github.com/LeoooY" target="_blank" rel="noopener noreferrer">LeoY</a></p><p>对于刚接触 <code>Blink</code> 的开发者来说， <code>Blink</code> 相关的工作并不简单。因为实现一个高效快速的渲染引擎，需要了解大量与 <code>Blink</code> 相关的概念和代码约定。这对于经验丰富的 <code>Blink</code> 开发者来说也并不简单，因为 <code>Blink</code> 项目很庞大，并且对于性能、内存和安全性很敏感。</p><p>本文的目标是提供一个关于 <code>Blink</code> 工作原理的概览，希望能够帮助开发者快速熟悉 <code>Blink</code> 的架构。</p><ul><li>本文不是一个关于 <code>Blink</code> 架构细节和代码风格的详细教程，而是关于 <code>Blink</code> 基本原理的简单介绍。这部分原理在短期内不会有大的改变，另外提供了一些深入了解这些部分的相关资源。</li><li>本文不会介绍具体的功能（比如 <code>ServiceWorkers</code> ， <code>editing</code> 等），而是介绍了代码中广泛使用的一些基本的功能（比如内存管理， <code>V8 APIs</code> 等）</li></ul><p>访问 <a href="https://www.chromium.org/blink" target="_blank" rel="noopener noreferrer">Chromium wiki page</a> 来获取更多的关于 <code>Blink</code> 开发的信息</p><ul><li><a href="#blink-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">Blink 是如何工作的</a><ul><li><a href="#blink-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><code>Blink</code> 做了什么</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B-%E6%9E%B6%E6%9E%84">进程/线程 架构</a><ul><li><a href="#%E8%BF%9B%E7%A8%8B">进程</a></li><li><a href="#%E7%BA%BF%E7%A8%8B">线程</a></li><li><a href="#blink-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%BB%88%E6%AD%A2"><code>Blink</code> 的初始化和终止</a></li></ul></li><li><a href="#%E7%9B%AE%E5%BD%95%E6%9E%B6%E6%9E%84">目录架构</a><ul><li><a href="#content-public-apis-%E5%92%8C-blink-public-apis"><code>Content public APIs</code> 和 <code>Blink public APIs</code></a></li><li><a href="#%E7%9B%AE%E5%BD%95%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BE%9D%E8%B5%96">目录架构和依赖</a></li><li><a href="#wtf">WTF</a></li></ul></li><li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a></li><li><a href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6">任务调度</a></li><li><a href="#page--frame--document--domwindow-etc"><code>Page</code> , <code>Frame</code> , <code>Document</code> , <code>DOMWindow</code> etc</a><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#out-of-process-iframes-oopif-%E8%BF%9B%E7%A8%8B%E5%A4%96%E7%9A%84iframe">Out-of-Process iframes (OOPIF 进程外的iframe)</a></li><li><a href="#detached-frame--document--%E5%88%86%E7%A6%BB%E7%9A%84frame--document">Detached Frame / Document  分离的Frame / Document</a></li></ul></li><li><a href="#web-idl-bindings-web-idl%E7%BB%91%E5%AE%9A">Web IDL bindings: Web IDL绑定</a></li><li><a href="#v8-%E5%92%8C-blink">V8 和 Blink</a><ul><li><a href="#isolate-context-world">Isolate, Context, World</a></li><li><a href="#v8-apis">V8 APIs</a></li><li><a href="#v8-wrappers">V8 wrappers</a></li></ul></li><li><a href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E9%81%93-rendering-pipeline">渲染管道 Rendering pipeline</a></li><li><a href="#questions">Questions?</a></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="blink-做了什么"></a><code>Blink</code> 做了什么<a aria-hidden="true" tabindex="-1" class="hash-link" href="#blink-做了什么" title="Direct link to heading">#</a></h2><p><a href="https://www.chromium.org/blink" target="_blank" rel="noopener noreferrer"> <code>Blink</code> </a> 是一个Web平台的渲染引擎。粗略地说，在一个浏览器tab页中与内容渲染相关的所有事情都是由 <code>Blink</code> 实现的。</p><ul><li><p>实现Web平台的规格（比如, <a href="https://html.spec.whatwg.org/multipage/?" target="_blank" rel="noopener noreferrer">HTML标准规格</a>），包括 <code>DOM</code> , <code>CSS</code> 和 <code>Web IDL</code> (<a href="https://en.wikipedia.org/wiki/Web_IDL" target="_blank" rel="noopener noreferrer">Web浏览器编程接口描述</a>)</p></li><li><p>嵌入 <code>V8</code> 和运行 <code>Javascript</code></p></li><li><p>从底层的网络堆栈请求资源</p></li><li><p>构建 <code>DOM tree</code></p></li><li><p>计算样式和布局</p></li><li><p>嵌入 <a href="https://chromium.googlesource.com/chromium/src/+/HEAD/cc/README.md"> <code>Chrome Compositor</code> </a> 和图形渲染绘制</p><ul><li><p>what is Chrome Compositor?</p><blockquote><p>cc is responsible for taking painted inputs from its embedder, figuring out where and if they appear on screen, rasterizing and decoding and animating images from the painted input into gpu textures, and finally forwarding those textures on to the display compositor in the form of a compositor frame. cc also handles input forwarded from the browser process to handle pinch and scroll gestures responsively without involving Blink.</p></blockquote></li></ul></li></ul><p>在很多地方都能见到 <code>Blink</code> 的身影，比如 <code>Chromium</code> ， <code>Android WebView</code> 以及通过 <a href="https://chromium.googlesource.com/chromium/src/+/HEAD/content/public/README.md">content public APIs</a> 内嵌 <code>Blink</code> 的 <code>Opera</code> 浏览器。</p><p><img src="images/image3.png"></p><p>从代码库的角度来看， <code>Blink</code> 对应 <code>//third_party/blink/</code> 。
从项目本身来看， <code>Blink</code> 实现了Web平台的功能，这些代码在主要在 <code>//third_party/blink/</code> ， <code>//content/renderer/</code> ， <code>//content/browser/</code> 目录中。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="进程线程-架构"></a>进程/线程 架构<a aria-hidden="true" tabindex="-1" class="hash-link" href="#进程线程-架构" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="进程"></a>进程<a aria-hidden="true" tabindex="-1" class="hash-link" href="#进程" title="Direct link to heading">#</a></h3><p><code>Chromium</code> 是一个 <a href="https://www.chromium.org/developers/design-documents/multi-process-architecture" target="_blank" rel="noopener noreferrer">多进程架构 multi-process architecture</a> 的浏览器引擎 。 <code>Chromium</code> 运行时会创建一个浏览器进程和N个在沙盒中运行的渲染进程。 <code>Blink</code> 则是在渲染进程中运行的。</p><p>创建多少渲染进程？一般来说，一个 <code>site</code> 会独占一个渲染进程，而当用户开太多tabs页面内存不足时，多个 <code>site</code> 可能会共享一个渲染进程。</p><blockquote><p>出于安全性的考虑，跨站文档（cross-site documents）的内存地址会被隔离开来（这被称为<a href="https://www.chromium.org/Home/chromium-security/site-isolation" target="_blank" rel="noopener noreferrer">Site Isolation</a>）。理想情况下，每个渲染进程是每个网站专用的，然而当用户打开太多标签页或者机器内存不够时，这种限制就很麻烦。所以实际上，多个页面或者不同网站的多个 <code>iframe</code> 可能会共享同一个渲染。这意味着一个tab页中的多个 <code>iframe</code> 可能是不同的渲染进程渲染的，不同的tab页中的 <code>iframe</code> 也有有可能是同一个渲染进程渲染的。<strong>所以渲染进程，iframe 和 tab 三者之间不是（1：1）一对一的映射关系</strong></p></blockquote><p>由于渲染进程是运行在沙盒中的，所以 <code>Blink</code> 需要向浏览器进程发起系统调用（比如文件访问，音频播放）和（用户配置）数据的获取（比如 <code>Cookie</code> ，密码）。浏览器进程和渲染进程之间通过 <a href="https://chromium.googlesource.com/chromium/src/+/master/mojo/README.md">Mojo</a> 实现通信。（Note: 以前是通过 <a href="https://www.chromium.org/developers/design-documents/inter-process-communication" target="_blank" rel="noopener noreferrer">Chromium IPC</a> 实现，现在还有部分代码仍在使用，但是会逐渐弃用） <code>Chromium</code> 中的 <code>Servicification</code> 将浏览器进程封装出了一些独立的服务。 <code>Blink</code> 可以直接使用 <code>Mojo</code> 调用这些独立服务来或者与浏览器进程交互。</p><p><img src="images/image5.png"></p><p>了解更多：</p><ul><li><a href="https://www.chromium.org/developers/design-documents/multi-process-architecture" target="_blank" rel="noopener noreferrer">多进程架构 Multi-process Architecture</a></li><li>在Blink中使用Mojo进行开发 Mojo programming in Blink: platform/mojo/MojoProgrammingInBlink. md</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="线程"></a>线程<a aria-hidden="true" tabindex="-1" class="hash-link" href="#线程" title="Direct link to heading">#</a></h3><p>在一个渲染进程中创建了多少线程？</p><p><code>Blink</code> 中会有一个主线程，N个工作线程和三两个内部线程。</p><p>几乎所有重要的事情都发生在主线程中。 <code>Javascript</code> （不包括 <code>service worker</code> ）， <code>DOM</code> ， <code>CSS</code> ，样式和布局计算都在主线程中运行。
<code>Blink</code> 通过许多优化来最大化主线程的性能，模拟了一个近乎单线程的架构。
<code>Blink</code> 可能会创建多个工作线程来运行 <a href="https://html.spec.whatwg.org/multipage/workers.html#workers"> <code>Web Workers</code> </a>，<a href="https://w3c.github.io/ServiceWorker/" target="_blank" rel="noopener noreferrer"> <code>ServiceWorker</code> </a>以及<a href="https://www.w3.org/TR/worklets-1/" target="_blank" rel="noopener noreferrer"> <code>Worklet</code> </a>。
<code>Blink</code> 和 <code>V8</code> 可能会创建三两个内部进程来处理 <code>音频 webaudio</code> , <code>数据库 database</code> , <code>内存回收 GC</code> 等。</p><p>线程之间的通信，需要使用 <code>PostTask APIs</code> 来传递。
出于性能的考虑，除了几个特别的地方，共享内存编程是不推荐的，所以在 <code>Blink</code> 中源码中也很少使用互斥锁这种东西。</p><p><img src="images/image2.png"></p><p>了解更多：</p><ul><li><code>Blink</code> 中的线程: platform/wtf/ThreadProgrammingInBlink. md</li><li>Workers: <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/workers/README.md">core/workers/README. md</a></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="blink-的初始化和终止"></a><code>Blink</code> 的初始化和终止<a aria-hidden="true" tabindex="-1" class="hash-link" href="#blink-的初始化和终止" title="Direct link to heading">#</a></h3><p><code>Blink</code> 通过<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/controller/blink_initializer.cc?sq=package:chromium&amp;dr=C&amp;g=0&amp;l=86"> <code>BlinkInitializer::Initialize()</code> </a>来初始化。这个方法必须在执行 <code>Blink</code> 代码前调用。</p><p><code>Blink</code> 没有终止化的状态，原因是渲染进程是被强制退出的，而不是被清理回收的。原因之一是出于性能的考虑（强制退出不需要做额外的操作）。另一个原因是渲染进程在正常退出的情况下，一般很难把所以东西都清理回收掉。（并且这样做的代价高于带来的效益）</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="目录架构"></a>目录架构<a aria-hidden="true" tabindex="-1" class="hash-link" href="#目录架构" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="content-public-apis-和-blink-public-apis"></a><code>Content public APIs</code> 和 <code>Blink public APIs</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#content-public-apis-和-blink-public-apis" title="Direct link to heading">#</a></h3><p><a href="https://cs.chromium.org/chromium/src/content/public/" target="_blank" rel="noopener noreferrer"> <code>Content public APIs</code> </a>是用嵌入渲染引擎的API层。 <code>Content public APIs</code> 必须小心维护，因为它们是提供给（想内嵌 <code>Blink</code> 引擎的）嵌入器的。</p><p><a href="https://cs.chromium.org/chromium/src/third_party/blink/public/?q=blink/public&amp;sq=package:chromium&amp;dr" target="_blank" rel="noopener noreferrer"> <code>Blink public APIs</code> </a>是为 <code>Chromium</code> 提供 <code>//third_party/blink/</code> 中的 <code>Blink</code> 功能的API层。 <code>Blink public APIs</code> 继承自 <code>Webkit APIs</code> 。在 <code>Webkit</code> 时代，由于 <code>Chromium</code> 和 <code>Safari</code> 会共享 <code>Webkit</code> 的实现，所以当时这个API层既要顾及 <code>Chromium</code> 也要顾及 <code>Safari</code> 。而现在 <code>Blink</code> 内核的功能只需要提供给 <code>Chromium</code> ，旧的API层有些API就不需要了。所以我们将 <code>Chromium</code> 中与平台相关的代码迁移到 <code>Blink</code> 中来减少 <code>Blink public APIs</code> 的数量（这个项目被叫作 <code>Onion Soup</code> ）</p><p><img src="images/image1.png" alt="img"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="目录架构和依赖"></a>目录架构和依赖<a aria-hidden="true" tabindex="-1" class="hash-link" href="#目录架构和依赖" title="Direct link to heading">#</a></h3><p><code>//third_party/blink/</code> 的目录如下，查阅<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/README.md">这个文档</a>了解更多。</p><ul><li>platform/<ul><li>一组从core/里面分解出来的 <code>Blink</code> 底层功能，比如地理位置 <code>geometry</code> 和图形 <code>graphics</code> 相关的库</li></ul></li><li>core/ 和 modules/<ul><li>实现Web平台规格文件的所有功能。core/主要是实现 <code>DOM</code> 相关的功能。modules/主要实现了一些浏览器自有的功能，比如 <code>webaudio</code> , <code>indexeddb</code> 。</li></ul></li><li>bindings/core/ 和 bindings/modules/<ul><li>从命名就可以猜到， <code>bindings/core/</code> 是 <code>core/</code> 的一部分， <code>bindings/modules/</code> 是 <code>modules/</code> 的一部分。频繁调用 <code>V8 APIs</code> 的文件都放在 <code>bindings/{core,modules}</code> 里面</li></ul></li><li>controller/<ul><li>一些调用 <code>core/</code> 和 <code>modules/</code> 的顶层工具库（比如devtools的前端部分 <code>devtools front-end</code> ）</li></ul></li></ul><p>各部分代码的依赖关系如下：</p><ul><li><code>Chromium</code> =&gt; <code>controller/</code> =&gt; <code>modules/</code> 和 <code>bindings/modules/</code> =&gt; <code>core/</code> 和 <code>bindings/core/</code> =&gt; <code>platform/</code> =&gt; 底层原语 比如 <code>//base</code> , <code>//v8</code> 和 <code>//cc</code>
提供给 <code>//third_party/blink/</code> 底层原语在 <code>Blink</code> 项目中被小心翼翼地精心维护着</li></ul><p>了解更多：</p><ul><li>目录架构和依赖：<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/README.md">blink/renderer/README. md</a></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="wtf"></a>WTF<a aria-hidden="true" tabindex="-1" class="hash-link" href="#wtf" title="Direct link to heading">#</a></h3><p><code>WTF</code> 是 <code>Blink</code> 特有的工具库，位于 <code>platform/wtf/</code> 。我们尽可能统一 <code>Chromium</code> 和 <code>Blink</code> 的代码，所以 <code>WTF</code> 的体积会很小。 <code>WTF</code> 这个工具库之所以存在，是因为对于 <code>Blink</code> 的工作负载和 <code>Oilpan</code> (即 <code>Blink GC</code> ) 中有大量的类型（ <code>types</code> ），容器（ <code>containers</code> ）和宏（ <code>macros</code> ）需要做性能优化。如果类型在 <code>WTF</code> 中有相应的定义，在 <code>Blink</code> 中就需要使用 <code>WTF</code> 的类型而不是定义在 <code>//base</code> 或者 <code>std libraries</code> 中的类型。
使用的最多的类型是 <code>vectors</code> , <code>hashsets</code> , <code>hashmaps</code> 和 <code>strings</code> 。相应的在 <code>Blink</code> 中应该使用 <code>WTF::Vector</code> , <code>WTF::HashSet</code> , <code>WTF::HashMap</code> , <code>WTF::String</code> 和 <code>WTF::AtomicString</code> 而不是 <code>std::vector</code> , <code>std::*set,</code>  <code>std::*map</code> 和 <code>std::string</code> 。</p><p>了解更多:</p><ul><li>如何使用 <code>WTF</code> : <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/wtf/README.md">platform/wtf/README. md</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="内存管理"></a>内存管理<a aria-hidden="true" tabindex="-1" class="hash-link" href="#内存管理" title="Direct link to heading">#</a></h2><p>你需要关注三个与 <code>Blink</code> 相关的内存分配器。</p><ul><li><a href="https://chromium.googlesource.com/chromium/src/+/master/base/allocator/partition_allocator/PartitionAlloc.md">PartitionAlloc</a></li><li><a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md">Oilpan</a> (即Blink GC)</li><li>malloc/free or new/delete (禁止使用c++原生的)</li></ul><p>给一个对象分配 <code>PartitionAlloc</code> 上的堆内存，可以用 <code>USING_FAST_MALLOC()</code></p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class SomeObject {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  USING_FAST_MALLOC(SomeObject);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static std::unique_ptr&lt;SomeObject&gt; Create() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return std::make_unique&lt;SomeObject&gt;();  // Allocated on PartitionAlloc&#x27;s heap.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>一个由 <code>PartitionAlloc</code> 分配的对象的生命周期应该被 <code>scoped_refptr&lt;&gt;</code> 和 <code>std::unique_ptr&lt;&gt;</code> 管理。强烈不建议手动去管理生命周期。手动回收内存在 <code>Blink</code> 是不允许的。</p><p>给一个对象分配 <code>Oilpan</code> 上的堆内存，你可以使用 <code>GarbageCollected</code> 。</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class SomeObject : public GarbageCollected&lt;SomeObject&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static SomeObject* Create() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return new SomeObject;  // Allocated on Oilpan&#x27;s heap.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p><code>Oilpan</code> 堆内存中的对象生命周期是由 <code>garbage collection</code> 自动管理的。你需要使用特殊的指针（比如 <code>Member&lt;&gt;</code> ， <code>Persistent&lt;&gt;</code> ）来存 <code>Oilpan</code> 堆内存中的对象。参考这个API手册<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md">this API reference</a>来熟悉在 <code>Oilpan</code> 上开发的一些限制。最重要的一个限制就是在一个 <code>Oilpan</code> 对象的解构函数中不允许处理任何其他的 <code>Oilpan</code> 对象。（原因是解构的顺序是没有保证的）</p><p>如果你既没有使用 <code>USING_FAST_MALLOC()</code> 也没有使用 <code>GarbageCollected</code> ，那么对象就被分配在系统堆内存中。这在 <code>Blink</code> 中是极其不推荐的。所有的 <code>Blink</code> 对象都应该按如下规则分配在 <code>PartitionAlloc</code> 或者 <code>Oilpan</code> 的堆内存中。</p><ul><li>默认使用 <code>Oilpan</code></li><li>仅在三种情况下使用 <code>PartitionAlloc</code><ul><li>对象的生命周期非常清晰，只用 <code>std::unique_ptr&lt;&gt;</code> 和 <code>scoped_refptr&lt;&gt;</code> 就可以满足需求</li><li>当使用 <code>Oilpan</code> 分配内存给当前情况增加很多的复杂性时</li><li>当使用 <code>Oilpan</code> 分配内存给当前情况的垃圾回收机制 <code>garbage collection runtime</code> 带来了大量不必要的（性能）压力时</li></ul></li></ul><p>不管使用 <code>PartitionAlloc</code> 还是 <code>Oilpan</code> 来分配内存，都需要极其小心，以免创建出悬空指针( <code>Dangling pointer</code> )甚至内存泄露(Note: 裸指针也是极其其不推荐的)</p><p>了解更多：</p><ul><li>如何使用 <code>PartitionAlloc</code> : <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/wtf/allocator/Allocator.md">platform/wtf/allocator/Allocator. md</a></li><li>如何使用 <code>Oilpan</code> : <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md">platform/heap/BlinkGCAPIReference. md</a></li><li>Oilpan GC 设计: <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCDesign.md">platform/heap/BlinkGCDesign. md</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="任务调度"></a>任务调度<a aria-hidden="true" tabindex="-1" class="hash-link" href="#任务调度" title="Direct link to heading">#</a></h2><p>为了提升渲染引擎的响应速度，在 <code>Blink</code> 中的任务都应该尽可能的异步执行。同步的 <code>IPC/Mojo</code> 或者其他可能耗费数毫秒的操作都是不推荐使用的。（尽管有些操作无法避免，比如执行用户的 <code>JavaScript</code> ，其 <code>JavaScript</code> 代码本身可能会阻塞渲染）。</p><p>在渲染进程中的所有任务都会通知<a href="https://chromium.googlesource.com/chromium/src/+/lkcr/third_party/WebKit/Source/platform/scheduler/README.md"> <code>Blink Scheduler</code> </a>，且提供自己相应的任务类型，如下面这样：</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Post a task to frame&#x27;s scheduler with a task type of kNetworking</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">frame-&gt;GetTaskRunner(TaskType::kNetworking)-&gt;PostTask(..., WTF::Bind(&amp;Function));</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p><code>Blink Scheduler</code> 维护着多个任务队列，并根据任务的优先级自动进行排序来提升性能，最大化提升用户体验。提供<a href="https://cs.chromium.org/chromium/src/third_party/blink/public/platform/task_type.h?q=blink+tasktype&amp;sq=package:chromium&amp;dr=CSs&amp;l=5">正确的任务类型</a>对于 <code>Blink Schedule</code> 的高效调度是十分重要的。</p><p>了解更多：</p><ul><li>How to post tasks 如何发起任务: platform/scheduler/PostTask. md</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="page--frame--document--domwindow-etc"></a><code>Page</code> , <code>Frame</code> , <code>Document</code> , <code>DOMWindow</code> etc<a aria-hidden="true" tabindex="-1" class="hash-link" href="#page--frame--document--domwindow-etc" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="概念"></a>概念<a aria-hidden="true" tabindex="-1" class="hash-link" href="#概念" title="Direct link to heading">#</a></h3><p><code>Page</code> , <code>Frame</code> , <code>Document</code> , <code>ExecutionContext</code> 和 <code>DOMWindow</code> 的含义如下：</p><ul><li><code>Page</code> 对应tab页（如果下文介绍的 <code>OOPIF</code> 没有开启的话）。一个渲染进程可能会渲染多个tab页</li><li><code>Frame</code> 对应 <code>frame</code> ( <code>main frame</code> 或者一个 <code>iframe</code> )。一个 <code>Page</code> 包含一个或者多个 <code>Frame</code> 并且包含在一个树结构中。</li><li><code>DOMWindow</code> 对应 <code>Javascript</code> 中的 <code>window</code> 对象。每个 <code>Frame</code> 有一个 <code>DOMWindow</code> 。</li><li><code>Document</code> 对应 <code>Javascript</code> 中的 <code>window.document</code> 对象。每个 <code>Frame</code> 有一个 <code>Document</code> 。</li><li><code>ExecutionContext</code> 是（主线程的） <code>Document</code> 和（工作线程的） <code>WorkerGlobalScope</code> 的抽象。</li></ul><p>渲染进程 ： <code>Page</code> = 1 : N.
<code>Page</code> : <code>Frame</code> = 1 : M.
<code>Frame</code> : <code>DOMWindow</code> : <code>Document</code> (or <code>ExecutionContext</code> ) = 1 : 1 : 1（在任何时刻都成立，不过映射关系可能会改变）</p><p>举个栗子：</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">iframe.contentWindow.location.href = &quot;https://example.com&quot;;</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>在这种情况下，访问 <code>https://example.com.</code> 创建了新的 <code>DOMWindow</code> 和 <code>Document</code> ，而 <code>Frame</code> 则可能被重用。（Note: 准确的来说，还存在一些<a href="https://docs.google.com/presentation/d/1pHjF3TNCX--j0ss3SK09pXlVOFK0Cdq6HkMcOzcov1o/edit#slide=id.g4983c55b2d55fcc7_42">更复杂的情况</a>创建了新的 <code>Document</code> ，而 <code>DOMWindow</code> 和 <code>Frame</code> 被重用了）。</p><p>了解更多：</p><ul><li>core/frame/FrameLifecycle. md</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="out-of-process-iframes-oopif-进程外的iframe"></a>Out-of-Process iframes (OOPIF 进程外的iframe)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#out-of-process-iframes-oopif-进程外的iframe" title="Direct link to heading">#</a></h3><p><a href="https://www.chromium.org/developers/design-documents/site-isolation" target="_blank" rel="noopener noreferrer">Site Isolation</a> 网站隔离增加了安全性的同时也增加了复杂性。:) <code>Site Isolation</code> 的设想是为每一个网站创建一个渲染进程 。</p><p>(A site is a page’s registrable domain + 1 label, and its URL scheme. For example, <a href="https://mail.example.com">https://mail.example.com</a> and <a href="https://chat.example.com">https://chat.example.com</a> are in the same site, but <a href="https://noodles.com">https://noodles.com</a> and <a href="https://pumpkins.com">https://pumpkins.com</a> are not. )</p><p>如果 <code>Page</code> 包含跨站的 <code>iframe</code> , 那么这个 <code>Page</code> 可能被两个渲染进程共同渲染。参考下面这种 <code>Page</code> :</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;!-- https://example.com --&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;body&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;iframe src=&quot;https://example2.com&quot;&gt;&lt;/iframe&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;/body&gt;</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>主 <code>frame</code> 和 <code>iframe</code> 可能运行在不同的渲染进程中。渲染进程本地的 <code>frame</code> 由 <code>LocalFrame</code> 呈现，不属于渲染进程本地的 <code>frame</code> 由 <code>RemoteFrame</code> 呈现。</p><p>从主 <code>frame</code> 的角度来看，主 <code>frame</code> 是一个 <code>LocalFrame</code> 而 <code>iframe</code> 是一个 <code>RemoteFrame</code> 。从 <code>iframe</code> 的角度来看，主 <code>frame</code> 是一个 <code>RemoteFrame</code> ，而 <code>iframe</code> 是一个 <code>LocalFrame</code> 。</p><p><code>LocalFrame</code> 和 <code>RemoteFrame</code> （两者可能存在与不同的渲染进程中）之间的通信是浏览器进程来处理的。</p><p>了解更多：</p><ul><li><p>Design docs 设计文档： <a href="https://www.chromium.org/developers/design-documents/site-isolation" target="_blank" rel="noopener noreferrer">Site isolation design docs</a></p></li><li><p>How to write code with site isolation： core/frame/SiteIsolation. md</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="detached-frame--document--分离的frame--document"></a>Detached Frame / Document  分离的Frame / Document<a aria-hidden="true" tabindex="-1" class="hash-link" href="#detached-frame--document--分离的frame--document" title="Direct link to heading">#</a></h3><p><code>Frame</code> / <code>Document</code> 可能处于分离的状态。参考下面的栗子：</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">doc = iframe.contentDocument;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">iframe.remove();  // The iframe is detached from the DOM tree.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">doc.createElement(&quot;div&quot;);  // But you still can run scripts on the detached frame.</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>一个很骚的事实是，在分离的 <code>frame</code> 中你仍能够运行脚本和执行DOM操作。由于 <code>frame</code> 已经被分离，大部分DOM操作会失败并报错。可惜分离的 <code> frame</code> 的表现在不同浏览器中并不一致，在规格文件中也没有非常明确的定义。大体上来说，期望的表现是在 <code>frame</code> 分离后 <code>JavaScript</code> 还是可以正常的执行，但是大多数DOM操作都应该失败并抛出异常，如：</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void someDOMOperation(...) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (!script_state_-&gt;ContextIsValid()) { // The frame is already detached</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    …;  // Set an exception etc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>这意味着 <code>Blink</code> 需要在 <code>frame</code> 被分离时做大量的清除回收操作。这些操作可以通过<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/dom/context_lifecycle_observer.h?type=cs&amp;q=contextlifecycleobserver&amp;sq=package:chromium&amp;g=0&amp;l=95"> <code>ContextLifecycleObserver</code> </a>继承而来，如：</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class SomeObject : public GarbageCollected&lt;SomeObject&gt;, public ContextLifecycleObserver {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void ContextDestroyed() override {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Do clean-up operations here.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ~SomeObject() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // It&#x27;s not a good idea to do clean-up operations here because it&#x27;s too late to do them. Also a destructor is not allowed to touch any other objects on Oilpan&#x27;s heap.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="web-idl-bindings-web-idl绑定"></a>Web IDL bindings: Web IDL绑定<a aria-hidden="true" tabindex="-1" class="hash-link" href="#web-idl-bindings-web-idl绑定" title="Direct link to heading">#</a></h2><p>当 <code>JavaScript</code> 访问 <code>node.firstChild</code> 的时候， <code>node.h</code> 中的 <code>Node::firstChild()</code> 即被调用。它是如何工作的呢，一起来看看 <code>node.firstChild</code> 是怎么工作的：</p><p>首先，你需要为每一个规格定义一个IDL文件，如：</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// node.idl</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">interface Node : EventTarget {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  [...] readonly attribute Node? firstChild;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>Web IDL的语法定义在 <a href="https://heycam.github.io/webidl/" target="_blank" rel="noopener noreferrer">the Web IDL spec</a> 中。 <code>[...]</code> 被称为 <code>IDL extended attributes</code> 。
<code>the Web IDL spec</code> 里面定义了一些 <code>IDL extended attributes</code> ，其他的在<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/bindings/IDLExtendedAttributes.md"> Blink-specific IDL extended attributes</a>中。除了 <code>Blink</code> 特有的 <code>IDL extended attributes</code> ，其他IDL文件都应该按照和规格文件一致的格式来写（意思就是直接从规格文件里面cv）。</p><p>接下来，你需要为 <code>Node</code> 节点定义一个 <code>C++ class</code> 类，并用c++实现 <code>firstChild</code> 的 <code>getter</code> ，如：</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class EventTarget : public ScriptWrappable {  // All classes exposed to JavaScript must inherit from ScriptWrappable.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Node : public EventTarget {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DEFINE_WRAPPERTYPEINFO();  // All classes that have IDL files must have this macro.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Node* firstChild() const { return first_child_; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>大多数情况下，这样就可以了。当你构建 <code>node.idl</code> ，<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/bindings/IDLCompiler.md"> <code>the IDL compiler</code> </a>会为 <code>Node interface</code> 和 <code>Node.firstChild</code> 自动生成 <code>Blink</code> - <code>V8</code> 的绑定。这个自动生成绑定的操作位于<a href="https://cs.chromium.org/chromium/src/out/Debug/gen/third_party/blink/renderer/bindings/core/v8/v8_node.h?q=v8node&amp;sq=package:chromium&amp;dr=CSs&amp;l=11"> <code>//src/out/{Debug,Release}/gen/third_party/ blink/renderer/bindings/core/v8/v8_node.h</code> </a>中。当 <code>JavaScript</code> 调用 <code>node.firstChild</code> 时， <code>V8</code> 就从 <code>v8_node.h</code> 去调用 <code> V8Node::firstChildAttributeGetterCallback()</code> ，接着就会调用你上面定义的 <code>Node::firstChild()</code> 。</p><p>了解更多：</p><ul><li>How to add Web IDL bindings: bindings/IDLCompiler. md</li><li>How to use IDL extended attributes: bindings/- IDLExtendedAttributes. md</li><li>Spec: Web IDL spec</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="v8-和-blink"></a>V8 和 Blink<a aria-hidden="true" tabindex="-1" class="hash-link" href="#v8-和-blink" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="isolate-context-world"></a>Isolate, Context, World<a aria-hidden="true" tabindex="-1" class="hash-link" href="#isolate-context-world" title="Direct link to heading">#</a></h3><p>当你写和 <code>V8 APIs</code> 有关的代码时，理解 <code>Isolate, Context, World</code> 这三个概念很重要。它们在代码库中分别是 <code>v8::Isolate</code> , <code>v8::Context</code> 和 <code>DOMWrapperWorld</code> 。</p><p><code>Isolate</code> 是一个物理上的线程，在 <code>Blink</code> 中 <code>Isolate : physical=1：1</code> 。主线程和工作线程都有其独立的 <code>Isolate</code> 。</p><p><code>Context</code> 是一个全局的对象（以 <code>Frame</code> 来说， <code>Frame</code> 的 <code>Context</code> 是 <code>window</code> 对象）。由于每个 <code>frame</code> 有自己的 <code>window</code> 对象，所以一个渲染进程中会有多个 <code>Context</code> 。当调用 <code>V8 APIs</code> 时，你需要确认你在正确的 <code>Context</code> 中。否则， <code>v8::Isolate::GetCurrentContext()</code> 就会返回一个不正确的 <code>Context</code> ，最坏的情况会造成对象泄露并导致安全问题。</p><p><code>World</code> 支撑 <code>Chrome extensions</code> 脚本的运行。 <code>Worlds</code> 和任何web标准都没有关系。 <code>Chrome extensions</code> 脚本和页面共享DOM，不过处于安全的考虑， <code>Chrome extensions</code> 脚本的 <code>JavaScript</code> 和页面的 <code>JavaScript</code> 堆内存是相互隔离的。（并且 <code>Chrome extensions</code> 脚本之间的 <code>JavaScript</code> 堆内存也是相互隔离的）。主线程通过为页面创建一个 <code>main world</code> 和为每个 <code>Chrome extensions</code> 脚本创建一个 <code>isolated world</code> 来实现隔离。 <code>main world</code> 和 <code>isolated worlds</code> 都可以访问到C++上的DOM对象，但是他们各自的 <code>JavaScript</code> 对象都是隔离的。这种隔离是通过为每个 <code>C++DOM</code> 对象创建多个 <code>V8 wrapper</code> 来实现的。即每个 <code>world</code> 对应一个 <code>V8 wrapper</code> 。</p><p><img src="images/image4.png"></p><p><code>Context</code> , <code>World</code> 和 <code>Frame</code> 之间有什么联系？
想象一下， 在主线程中存在N个 <code>World</code> （一个 <code>main world </code> +（N-1）个 <code>isolated worlds)</code> ）。那么一个 <code>Frame</code> 就有N个 <code>window objects</code> ，每个 <code>window objects</code> 对应一个 <code>world</code> 。而 <code>Context</code> 也是对应 <code>window objects</code> ，这意味着当存在N个 <code>Frame</code> 和N个 <code>Worlds</code> 的时候，有M*N个 <code>Contexts</code> （不过 <code>Contexts</code> 是懒加载创建的）</p><p>对于 <code>worker</code> 而言，只有一个 <code>World</code> 和一个 <code>global object</code> ，所以就只存在一个 <code>Context</code>
此外，当你使用 <code>V8 APIs</code> 的时候，你应该非常注意是否使用了正确的 <code>context</code> ，否则你可能导致在不同的 <code>isolated worlds</code> 间泄露 <code>JavaScript</code> 对象甚至导致灾难般的安全问题。（比如，使得A. com的 <code>Chrome extetion</code> 可以操纵B. com的 <code>Chrome extetion</code> ）</p><p>了解更多:</p><ul><li><a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/bindings/core/v8/V8BindingDesign.md">bindings/core/v8/V8BindingDesign. md</a></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="v8-apis"></a>V8 APIs<a aria-hidden="true" tabindex="-1" class="hash-link" href="#v8-apis" title="Direct link to heading">#</a></h3><p><a href="https://cs.chromium.org/chromium/src/v8/include/v8.h?q=v8.h&amp;sq=package:chromium&amp;dr=CSs&amp;l=10">//v8/include/v8. h. </a>里面有大量的V8 APIs。由于 <code>V8 APIs</code> 都比较底层，使用起来略显麻烦，所以一般使用<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/platform/bindings/?q=platform/bindings&amp;sq=package:chromium&amp;dr" target="_blank" rel="noopener noreferrer">platform/bindings/ </a> 提供的一组封装了的 <code>V8 APIs</code> 辅助类来（ <code>helper classes</code> ）进行调用。你应该尽量使用 <code>helper classes</code> 。如果你的代码中会重度使用原生 <code>V8 APIs</code> ，这些代码应该放到 <code>bindings/{core,modules}</code> 里面去。</p><p>V8使用 <code>handle</code> 来指向 <code>V8 objects</code> 。最常见的 <code>handle</code> 是 <code>v8::Local&lt;&gt;</code> , <code>v8::Local&lt;&gt;</code> 用于从机器堆栈 <code>machine stack</code> 指向 <code>V8 objects</code> 。 <code>v8::Local&lt;&gt;</code> 必须在 <code>v8::HandleScope</code> 从机器堆栈 <code>machine stack</code> 分配之后才能使用。 <code>v8::Local&lt;&gt;</code> 也不能在 <code>machine stack</code> 之外使用：</p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  v8::HandleScope scope;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  v8::Local&lt;v8::Object&gt; object = ...;  // This is correct.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class SomeObject : public GarbageCollected&lt;SomeObject&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  v8::Local&lt;v8::Object&gt; object_;  // This is wrong.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>要从机器堆栈 <code>machine stack</code> 指外指向 <code>V8 objects</code> ，你需要使用 <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/bindings/TraceWrapperReference.md">wrapper tracing</a>。然而你需要特别小心地使用，以免创建出循环引用。通常 <code>V8 APIs</code> 都是难用的。如果你不确定你的用法可以上<a href="https://groups.google.com/a/chromium.org/forum/#!forum/blink-reviews-bindings" target="_blank" rel="noopener noreferrer">blink-review-bindings@</a>提问。</p><p>了解更多：</p><ul><li>How to use V8 APIs and helper classes: platform/bindings/HowToUseV8FromBlink. md</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="v8-wrappers"></a>V8 wrappers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#v8-wrappers" title="Direct link to heading">#</a></h3><p>每个 <code>C++ DOM</code> 对象（比如，Node节点）都有其对应的 <code>V8 wrapper</code> 。准确的说，每个 <code>world</code> 的每个 <code>C++ DOM</code> 对象都有其对应的 <code>V8 wrapper</code> 。</p><p><code>V8 wrappers</code> 对它相应的 <code>C++ DOM</code> 是强引用关系。而 <code>C++ DOM</code> 对 <code>V8 wrappers</code> 则是弱引用关系。所以如果想要使 <code>V8 wrappers</code> 在一段特定的周期延续，你需要明确地指定。否则 <code>V8 wrappers</code> 可能会被提前回收，导致 <code>V8 wrappers</code> 上的 <code>JS properties</code> 丢失... </p><div class="mdxCodeBlock_iHAB"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">div = document.getElementbyId(&quot;div&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">child = div.firstChild;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">child.foo = &quot;bar&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">child = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">gc();  // If we don&#x27;t do anything, the V8 wrapper of |firstChild| is collected by the GC.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">assert(div.firstChild.foo === &quot;bar&quot;);  //...and this will fail.</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>如果什么都不做的话， <code>child</code> 就会被 <code>GC</code> 回收，即 <code>child.foo</code> 就不存在了。要保留 <code>div.firstChild</code> 上的 <code>V8 wrapper</code> 的话，我们需要增加一个机制来实现：只要 <code>div</code> 所属的 <code>DOM tree</code> 还可以通过 <code>V8</code> 访问到，就一直保留 <code>div.firstChild</code> 上的 <code>V8 wrapper</code> 。</p><p>有两种方式来保留 <code>V8 wrappers</code> ：<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/active_script_wrappable.h?q=activescriptwrappable&amp;sq=package:chromium&amp;dr=CSs&amp;l=16">ActiveScriptWrappable</a>和<a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/bindings/TraceWrapperReference.md">wrapper tracing. </a></p><p>了解更多：</p><ul><li>How to manage lifetime of V8 wrappers: bindings/core/v8/V8Wrapper. md</li><li>How to use wrapper tracing: <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/bindings/TraceWrapperReference.md">platform/bindings/TraceWrapperReference. md</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="渲染管道-rendering-pipeline"></a>渲染管道 Rendering pipeline<a aria-hidden="true" tabindex="-1" class="hash-link" href="#渲染管道-rendering-pipeline" title="Direct link to heading">#</a></h2><p>一个HTML文件从传递到 <code>Blink</code> 再到屏幕上显示的像素之间有一段很长的历程。渲染管道的架构如下：</p><p><img src="images/image6.png"></p><p><a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.p">Life of A Pixel</a>里面介绍了渲染管道的每一个阶段。</p><p>了解更多：</p><ul><li>overview: <a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.g60f92a5151_40_1415">Life of a Pixel</a></li><li>DOM: <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/dom/README.md">core/dom/README. md</a></li><li>Style: <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/css/README.md">core/css/README. md</a></li><li>Layout: <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/layout/README.md">core/layout/README. md</a></li><li>Paint： <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/paint/README.md">core/paint/README. md</a></li><li>Compositor thread: <a href="https://www.chromium.org/developers/design-documents/chromium-graphics" target="_blank" rel="noopener noreferrer">Chromium graphics</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="questions"></a>Questions?<a aria-hidden="true" tabindex="-1" class="hash-link" href="#questions" title="Direct link to heading">#</a></h2><p>有问题可以到 <a href="https://groups.google.com/a/chromium.org/forum/#!forum/blink-dev" target="_blank" rel="noopener noreferrer">blink-dev@chromium.org</a> 和 <a href="https://groups.google.com/a/chromium.org/forum/#!forum/platform-architecture-dev" target="_blank" rel="noopener noreferrer">platform-architecture-dev@chromium</a> 提问。</p></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« TCP3次握手和4次挥手</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/FE/React/doc-ReactHooks使用心得"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">ReactHooks使用心得 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_TbNY"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#blink-做了什么" class="table-of-contents__link"><code>Blink</code> 做了什么</a></li><li><a href="#进程线程-架构" class="table-of-contents__link">进程/线程 架构</a><ul><li><a href="#进程" class="table-of-contents__link">进程</a></li><li><a href="#线程" class="table-of-contents__link">线程</a></li><li><a href="#blink-的初始化和终止" class="table-of-contents__link"><code>Blink</code> 的初始化和终止</a></li></ul></li><li><a href="#目录架构" class="table-of-contents__link">目录架构</a><ul><li><a href="#content-public-apis-和-blink-public-apis" class="table-of-contents__link"><code>Content public APIs</code> 和 <code>Blink public APIs</code></a></li><li><a href="#目录架构和依赖" class="table-of-contents__link">目录架构和依赖</a></li><li><a href="#wtf" class="table-of-contents__link">WTF</a></li></ul></li><li><a href="#内存管理" class="table-of-contents__link">内存管理</a></li><li><a href="#任务调度" class="table-of-contents__link">任务调度</a></li><li><a href="#page--frame--document--domwindow-etc" class="table-of-contents__link"><code>Page</code> , <code>Frame</code> , <code>Document</code> , <code>DOMWindow</code> etc</a><ul><li><a href="#概念" class="table-of-contents__link">概念</a></li><li><a href="#out-of-process-iframes-oopif-进程外的iframe" class="table-of-contents__link">Out-of-Process iframes (OOPIF 进程外的iframe)</a></li><li><a href="#detached-frame--document--分离的frame--document" class="table-of-contents__link">Detached Frame / Document  分离的Frame / Document</a></li></ul></li><li><a href="#web-idl-bindings-web-idl绑定" class="table-of-contents__link">Web IDL bindings: Web IDL绑定</a></li><li><a href="#v8-和-blink" class="table-of-contents__link">V8 和 Blink</a><ul><li><a href="#isolate-context-world" class="table-of-contents__link">Isolate, Context, World</a></li><li><a href="#v8-apis" class="table-of-contents__link">V8 APIs</a></li><li><a href="#v8-wrappers" class="table-of-contents__link">V8 wrappers</a></li></ul></li><li><a href="#渲染管道-rendering-pipeline" class="table-of-contents__link">渲染管道 Rendering pipeline</a></li><li><a href="#questions" class="table-of-contents__link">Questions?</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="text--center"><div>Copyright © 2020 LeoY233. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.42bc322c.js"></script>
<script src="/runtime~main.3bd6ec28.js"></script>
<script src="/main.40fc54e8.js"></script>
<script src="/common.ee045f54.js"></script>
<script src="/2.358b1822.js"></script>
<script src="/3.2cdabb68.js"></script>
<script src="/1be78505.b7264bde.js"></script>
<script src="/28.c35099c0.js"></script>
<script src="/20ac7829.809bff99.js"></script>
<script src="/17896441.6709d3b9.js"></script>
<script src="/886b1f25.09ff3141.js"></script>
</body>
</html>